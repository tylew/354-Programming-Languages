\documentclass{article}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Go,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Tyler Lewis  \\ Chapman University}

\date{\today}

\begin{document}
\setlength\parindent{24pt}

\maketitle

\begin{abstract}
Updated throughout Fall 2022 for 354 Programming Languages at Chapman Univ.
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

Tylers introduction. Yeah, this will get some work before final submission. 


\section{Homework}\label{homework}

\subsection{Week 1}

% \section{Greatest Common Divisor (GCD)}
{\large \\\\Euclid's Algorithm\\\\}
Input: Two whole numbers (integers) called a and b, both greater than 0.

(1) if a {\textless} b then replace a by (a - b). 

(2) if b {\textgreater} a then replace b by (b - a).

(3) Repeat from (1) if a {\neq} b \\ 

Output: a.\\\\

{\large Code (Golang)}
\begin{lstlisting}
package main
import ( "fmt"; "strconv"; "os")
// Calculate GCD of a & b using Euclid's algorithm
func Euclid-GCD( a int, b int ) int {
    if a > b { return Euclid_GCD( a-b, b ) } // recursive GCD function
    if a < b { return Euclid_GCD( a, b-a ) } // Subtract lesser from greater
	return a // a == b End recursive function
} func main() {
    // Args(str) int conversion 
	a, err1 := strconv.Atoi(os.Args[1]); b, err2 := strconv.Atoi(os.Args[2])
    // If no errors:
	if err1 == nil && err2 == nil {
		gcd := Euclid_GCD( a, b ) // Evaluate GCD of args(int) => a, b
		fmt.Println(gcd) // Print divisor to console
		return // End script
    } fmt.Println("Error", err1, err2) // Errors happened
}
\end{lstlisting}

{\large Explaination\\}

Following the steps of Euclids algorithm detailed in section \texttt{{\bf Euclid's Algorithm}}, the GCD between any two numbers is determined. The Golang function, \texttt{{\bf Euclid-GCD}}, detailed step-by-step in section \texttt{{\bf Code (Golang)}}, determines the GCD by recursively subtracting one non-zero integer by the other.\\\\

{\large How to run:\\}
1--3 need only be done once:

(1) Install Golang

(2) Init Golang project: \texttt{go mod init} 

(3) Compile: \texttt{go build gcd.go} 

(4) Run: \texttt{./gcd.go [int arg1] [int arg2]} 

\subsection{Week 2}
{\large Task 1\\}
\begin{lstlisting}
select_evens :: [a] -> [a]
select_evens [] = []
select_evens (x:xs) = select_odds(xs)

select_odds :: [a] -> [a]
select_odds [] = []
select_odds (x:xs) = [x] ++ select_evens(xs)

revert :: [a] -> [a]  
revert [] = []  
revert (x:xs) = revert xs ++ [x]  

append :: [a] -> [a] -> [a]
append [] x = x
append (x:xs) b = x : append xs b
\end{lstlisting}

{\large Task 2\\}
append [2,5,4,3] 5 \\
-{\textgreater} [2]:[5]:[4]:[3]: 5 \\
-{\textgreater} [2,5,4,3,5]

\subsection{Week 3}
\begin{verbatim}

Completed 'fill in the dot' execution:
\end{verbatim}
\begin{lstlisting}
hanoi 5 0 2  
	hanoi 4 0 1 
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move  0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move  1 2  
				hanoi 1 0 2 = move 0 2 
		move 0 1
		hanoi 3 2 1
			hanoi 2 2 0
				hanoi 1 2 1 = move 2 1
				move 2 0
				hanoi 1 1 0 = move 1 0
			move 2 1
			hanoi 2 0 1
				hanoi 1 0 2 = move 0 2
				move 0 1
				hanoi 1 2 1 = move 2 1
	move 0 2
	hanoi 4 1 2
		hanoi 3 1 0
			hanoi 2 1 2
				hanoi 1 1 0 = move 1 0
				move 1 2
				hanoi 1 0 2 = move 0 2
			move 1 0
			hanoi 2 2 0
				hanoi 1 2 1 = move 2 1
				move 2 0
				hanoi 1 1 0 = move 1 0
		move 1 2
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move  0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move  1 2  
				hanoi 1 0 2 = move 0 2 
			|
		|
	|
|


\end{lstlisting}
\begin{verbatim}
The word 'hanoi' appears 31 times for a tower of height 5. Hanoi will execute {2^n - 1}  times

Javascript-ish formula to solve Tower of Hanoi with n discs:
\end{verbatim}
\begin{lstlisting}

func hanoi(  n, x, y ) {
	switch( n ) {
		case 1:
			move( x, y );
			break;
		default:
			hanoi ( n-1, x, other( x, y ) );
			move( x, y );
			hanoi ( n-1, other( x, y ), y );
			break;
	}
}

func move( x, y )  {
    // move top disk of position x to position y
}

func other( x, y ) {
	return (2 * ( x + y ))  % 3;
}

\end{lstlisting}

\subsection{Week 4}
{\large derivation trees\\}

\includegraphics[width=1\textwidth]{tree.jpeg}

{\large "More exercises"\\}
Why do the following strings not have parse trees (given the context-free grammar above)?

\begin{verbatim}
 2-1: No rule for subtraction
 1.0+2: Only rules for integers
 6/3: No specification for division
 8 mod 6: No specification for modulus
\end{verbatim}

Can you change the grammar, so that the strings in the previous exercise become parsable?

\begin{verbatim}
 yes you can, I would assume for modulus as well
\end{verbatim}

write out the abstract syntax trees for the following strings:
\begin{verbatim}
 2+1: Plus (Num 2) (Num 1)
 1+2*3: Plus (Num 1) (Times (Num 2) (Num 3))
 1+(2*3): Plus (Num 1) (Times (Num 2) (Num 3))
 (1+2)*3: Times (Plus (Num 1) (Num 2)) (Num 3)
\end{verbatim}

Is the abstract syntax tree of 1+2+3 identical to the one of (1+2)+3 or the one of 1+(2+3)?
\begin{verbatim}
 No particular right answer.
\end{verbatim}

\subsection{Week 5 (line 300)} 

Use the parser to generate linearized abstract syntax trees for the following expressions:

\parindent x
\begin{verbatim}
Prog (EVar (Id "x"))
\end{verbatim}
x x
\begin{verbatim}
Prog (EApp (EVar (Id "x")) (EVar (Id "x")))
\end{verbatim}
x y
\begin{verbatim}
Prog (EApp (EVar (Id "x")) (EVar (Id "y")))
\end{verbatim}
x y z
\begin{verbatim}
Prog (EApp (EApp (EVar (Id "x")) (EVar (Id "y"))) (EVar (Id "z")))
\end{verbatim}
\textbackslash x.x
\begin{verbatim}
Prog (EAbs (Id "x") (EVar (Id "x")))
\end{verbatim}
\textbackslash x.x x
\begin{verbatim}
Prog (EAbs (Id "x") (EApp (EVar (Id "x")) (EVar (Id "x"))))
\end{verbatim}
(\textbackslash x . (\textbackslash y . x y)) (\textbackslash x.x) z
\begin{verbatim}
Prog (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EApp (EVar (Id "x")) (EVar (Id "y"))))) (EAbs (Id "x") 
(EVar (Id "x")))) (EVar (Id "z")))
\end{verbatim}
(\textbackslash x . \textbackslash y . x y z) a b c
\begin{verbatim}
Prog (EApp (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EApp (EApp (EVar (Id "x")) 
(EVar (Id "y"))) (EVar (Id "z"))))) (EVar (Id "a"))) (EVar (Id "b"))) (EVar (Id "c")))
\end{verbatim}

Write out the abstract syntax trees in 2-dimensional notation using pen and paper.

\includegraphics[width=.80\textwidth]{wk5_abstracttrees.png}

Evaluate using pen-and-paper [2] the following expressions:

\includegraphics[width=.5\textwidth]{wk5_lambdasemantics.png}

Evaluate (\x.x)((\y.y)a) by executing the function evalCBN defined on line 26-28 in Interpreter.hs pen-and-paper. The function subst is doing capture avoiding substitution and you can reduce subst in one step in your pen and paper computation



\subsection{Week 6 (line 350)}

\begin{verbatim}
Reduce the following lambda calculus expression:

    (\exp . \two . \three . exp two three)
    (\m.\n. m n)
    (\f.\x. f (f x))
    (\f.\x. f (f (f x)))

 
    ( (\m.\n. m n) (\f.\x. f (f x)) (\f.\x. f (f (f x))) )  --β Substitution

    ( (\m.\n. m n) (\f.\x. f (f x)) (\x0.\x1. x0 (x0 (x0 x1))) )  --α conversion

    ( (\n.  (\f.(\x. f (f x))) n) (\x0.(\x1. x0 (x0 (x0 x1)))) )  --β Substitution

    ( (\f.(\x. f (f x))) (\x0.(\x1. x0 (x0 (x0 x1)))) )  --β Substitution

    ( ((\x. (\x0.(\x1. x0 (x0 (x0 x1)))) ((\x0.(\x1. x0 (x0 (x0 x1)))) x))) )  --β Substitution

    ( ((\x. (\x0.(\x1. x0 (x0 (x0 x1)))) ((\x2.(\x3. x2 (x2 (x2 x3)))) x))) )  --α conversion

    ( ((\x. ((\x1. ((\x2.(\x3. x2 (x2 (x2 x3)))) x) (((\x2.(\x3. x2 (x2 (x2 x3)))) x) 
    (((\x2.(\x3. x2 (x2 (x2 x3)))) x) x1)))) )) )  --β Substitution

    ( ((\x. ((\x1. ((\x2.(\x3. x2 (x2 (x2 x3)))) x) (((\x4.(\x5. x4 (x4 (x4 x5)))) x) 
    (((\x6.(\x7. x6 (x6 (x6 x7)))) x) x1)))) )) )  --α conversion

    ( ((\x. ((\x1. (\x3. x (x (x x3))) (((\x4.(\x5. x4 (x4 (x4 x5)))) x) 
    (((\x6.(\x7. x6 (x6 (x6 x7)))) x) x1)) )))))  --β Substitution

    (\x. (\x1. (x (x (x (((\x4.(\x5. x4 (x4 (x4 x5)))) x) (((\x6.(\x7. x6 (x6 (x6 x7)))) x) 
    x1)) )))))  --β Substitution

    (\x. (\x1. (x (x (x (((\x5. x (x (x x5)))) (((\x6.(\x7. x6 (x6 (x6 x7)))) x) 
    x1)) )))))  --β Substitution

    (\x. (\x1. (x (x (x (x (x (x (((\x6.(\x7. x6 (x6 (x6 x7)))) x) x1)))) )))))  --β Substitution

    (\x. (\x1. (x (x (x (x (x (x ((\x7. x (x (x x7))) x1)))) )))))  --β Substitution

    (\x. (\x1. (x (x (x (x (x (x (x (x (x x1)))))))) )))  --β Substitution, final

Algrbra formula:

    f(m,n) = n^m
\end{verbatim}

\subsection{Week 7 (line 400)}

1. \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/src/LambdaNat0/src/Interpreter-fragment.hs}{REFERENCE}, in lines 5-7 and also in lines 18-22 explain for each variable
\begin{itemize}
\item   Whether it is bound or free
\item   If it is bound say what  the binder and the scope of the variable are
\end{itemize}

\textit{lines 5-7:}

\textbf{evalCBN, and subst} are function names declared outside our scope and thus are \textbf{free}.

\textbf{EApp, and EAbs} are type variables declared elsewhere and thus are \textbf{free} within our scope. 

\textbf{e1, e2, e3, i, and x} are placeholders and can be interchanged with another fresh variable at will making them \textbf{bound}.

\textit{lines 18-22:}

\textbf{subst, and fresh} are function names declared outside our scope and thus are \textbf{free}.

\textbf{id, EAbs, and EVar} are type variables declared elsewhere and thus are \textbf{free} within our scope. 

\textbf{s, id1, e1, f, and e2} are placeholders and can be interchanged with another fresh variable at will making them \textbf{bound}.

2. evalCBN part of hw5 using equal sign
\begin{verbatim}
evalCBN( EApp (\x.x) ((\y.y) a) )

= EAbs x x → evalCBN( subst x ((\y.y) a) x )

= evalCBN( subst x ((\y.y) a) x )

= evalCBN( EApp (\y. y) a )

= EAbs y y → evalCBN(subst y a y)

= evalCBN(a)

= a
\end{verbatim}

3. This item is as the previous one, but for a different lambda term, namely `(\x.\y.x) y z`

\begin{verbatim}
(\x.\y. x) y z

= (\x.\y’. x) y z

= (\y’. y) z

= y
\end{verbatim}

4.  https://hackmd.io/@alexhkurz/BJ7AoGcVK

Consider the listed ARSs

\includegraphics[width=1\textwidth]{IMG_0034.jpg}

Try to find an example of an ARS for each of the possible 8 combinations.

\includegraphics[width=1\textwidth]{IMG_0035.jpg}

\includegraphics[width=.7\textwidth]{hw7diagram3.jpeg}

\subsection{Week 8 (line 450)}
Rewrite rules are
\begin{verbatim}
    aa -> a
    bb -> b
    ba -> ab
    ab -> ba
\end{verbatim}
\begin{itemize}
\item Why does the ARS not terminate?

The ARS can get caught in an infinite loop between ‘ab’ and ‘ba’

\item What are the normal forms?

Normal forms of the ARS are a & b

\item Can you change the rules so that the new ARS has unique normal forms (but still has the same equivalence relation)?
\begin{verbatim}
    aa -> a
    bb -> b
    ba -> ab
\end{verbatim}
\item What do the normal forms mean? Describe the function implemented by the ARS.

The normal forms is a reduction determining if the string contains either an a, b, or both.
a’s are sifted to left, while b’s are shifted to right, duplicates are reduced.
\end{itemize}

\subsection{Week 9 (line 470)}

consider the ARS:
\begin{verbatim}
    ba -> ab
    ab -> ba
    ac -> ca
    ca -> ac
    bc -> cb
    cb -> bc
 
    aa -> b
    ab -> c
    ac ->  
    bb ->
    cb -> a
    cc -> b
\end{verbatim}  
\begin{itemize}
\item Normal forms: a, b, c, and [] (empty string)

\item We can prove confluence by examining 3 letter combinations:

\includegraphics[width=.7\textwidth]{IMG_0045.jpg}

\item By assigning the following equalities:
\begin{verbatim}
    [] = 0
    a = 1
    b = 2
    c = 3

we are able to observe an invariance with the mathematical function:
    
    f(x,y) = (x + y) mod 4
    
\end{verbatim}

\end{itemize}

\subsection{Week 10 (line 520)}

\begin{verbatim}
1.
    let rec f = (\ x . S x) in f 0

    (\f. f 0) (\x. S x)
    (\x. S x) 0
    S 0

2.
    let rec f = (\ x . if x = 0 then 0 else f (minus_one x)) in f (S 0)

    (\f. f (S 0)) (\ x . if x = 0 then 0 else f (minus_one x))
    (\x. if x = 0 then 0 else f (minus_one x)) (S 0)
    if (S 0) = 0 then 0 else f (minus_one (S 0)) 
    f (minus_one (S 0))
    f (0) 

    (\.f f 0) (\ x . if x = 0 then 0 else f (minus_one x))
    (\ x . if x = 0 then 0 else f (minus_one x)) 0
    if 0 = 0 then 0 else f (minus_one 0)
    0

3.
    let rec f = (\ x . if x = 0 then 0 else f (minus_one x)) in f (S S 0)

    (\f. f (S S 0)) (\ x . if x = 0 then 0 else f (minus_one x))
    (\ x. if x = 0 then 0 else f (minus_one x)) (S S 0)
    if (S S 0) = 0 then 0 else f (minus_one (S S 0))
    f (minus_one (S S 0))
    f (S 0)

    (\.f f (S 0)) (\ x . if x = 0 then 0 else f (minus_one x))
    (\ x . if x = 0 then 0 else f (minus_one x)) (S 0)
    if (S 0) = 0 then 0 else f (minus_one (S 0))) 
    f (minus_one (S 0))) 
    f (0)

    (\.f f 0) (\ x . if x = 0 then 0 else f (minus_one x))
    (\ x . if x = 0 then 0 else f (minus_one x)) 0
    if 0 = 0 then 0 else f (minus_one 0)
    0

4.
    let rec f = (\ x . 
        if x = 0 
        then x 
        else c (f (minus_one x))) 
    in 
        f (S 0)

    (\f. f (S 0)) (\x. if x = 0 then x else c (f (minus_one x)))
    (\x. if x = 0 then x else c (f (minus_one x))) (S 0)
    if (S 0) = 0 then (S 0) else c (f (minus_one (S 0)))
    c (f (minus_one (S 0)))
    c (f (0))

    c ((\f. f 0) (\x. if x = 0 then x else c (f (minus_one x))))
    c ((\x. if x = 0 then x else c (f (minus_one x))) 0)
    c (if 0 = 0 then 0 else c (f (minus_one 0)))
    c (0)
\end{verbatim}

\subsection{Week 11}

A domain specific programming language (DSL) for financial contracts.
\\\\
What if the logic of our justice system was so fine-tuned it could be described in a DSL with precise inputs producing clear outputs? Before that though, we must of course consider legal contracts. Such DSL contracting languages have been proposed and developed mainly in the last 10 years, but none have achieved a legally recognized status. Despite this, trustworthy contracts are still being deployed, and functioning properly without the enforcement of a legal entity. I think my question is: is it possible to create a replacement enforcement entity through DSL's? and to what extent? Can laws of everyday life be determined by smart contracts?


\subsection{Week 12}
Apply the method of analysis from the lecture to
\begin{verbatim}
    while (x!=0) do z:=z*y;  x:= x-1 done
\end{verbatim}

What is the invariant? Indicate the reasoning steps in which you apply the rules of Hoare logic.
\\\\
Assuming z is initialized 1, an invariant of $z=y^{n-x}$ is observed. Such equation is a loop invariant and will return the value of z for each step in the looping function. 
\\\\
I derived this mathematical description by constructing a table of execution assuming $z = 1, x = n, y = m$ with arbitrary values for n and m. Additionally a variable T associated with the amount of executed loops in the sequence.
\\\\
On each loop, x iterates down by 1, while T counts up by 1, thus $T = n - x$. The value of z indicates a function describing y to the power of n - x (x, who's value is iterating down). 




% \ldots

\section{Project}

Smart Contract Programming Semantics

\subsection{Specification}

For my project I will compare different Smart Contract languages. The languages I have identified are Solidity (Ethereum VM), and Move (Sui VM).
\\\\
I will implement an identical project in both languages to explore and showcase key features and differences in either systems. 
\\\\
My project will be an auction house smart contract in which a seller will lock an NFT object within the contract, and users will bid under some criteria. The contract should act as an escrow service.
\\\\
Planned milestones are as follows:
\begin{itemize}
    \item Research and identify key differences between smart-contracting languages. Brainstorm project idea which incorporates notable differences.
    \item Build project in both languages and 
    \item Compile report on findings
\end{itemize}
    
% \href{https://www.stephendiehl.com/llvm/}{Possible launch point}

\subsection{Prototype}
\subsection{Documentation}
\subsection{Critical Appraisal}

\ldots

\section{Conclusions}\label{conclusions}

% (approx 400 words)

Thanks, goodbye.

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.
\end{thebibliography}

% \includegraphics {sss.png}
\end{document}
