\documentclass{article}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Go,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Tyler Lewis  \\ Chapman University}

\date{\today}

\begin{document}
\setlength\parindent{24pt}

\maketitle

\begin{abstract}
Updated throughout Fall 2022 for 354 Programming Languages at Chapman Univ.
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

Tylers introduction. Yeah, this will get some work before final submission. 


\section{Homework}\label{homework}

\subsection{Week 1}

% \section{Greatest Common Divisor (GCD)}
{\large \\\\Euclid's Algorithm\\\\}
Input: Two whole numbers (integers) called a and b, both greater than 0.

(1) if a {\textless} b then replace a by (a - b). 

(2) if b {\textgreater} a then replace b by (b - a).

(3) Repeat from (1) if a {\neq} b \\ 

Output: a.\\\\

{\large Code (Golang)}
\begin{lstlisting}
package main
import ( "fmt"; "strconv"; "os")
// Calculate GCD of a & b using Euclid's algorithm
func Euclid-GCD( a int, b int ) int {
    if a > b { return Euclid_GCD( a-b, b ) } // recursive GCD function
    if a < b { return Euclid_GCD( a, b-a ) } // Subtract lesser from greater
	return a // a == b End recursive function
} func main() {
    // Args(str) int conversion 
	a, err1 := strconv.Atoi(os.Args[1]); b, err2 := strconv.Atoi(os.Args[2])
    // If no errors:
	if err1 == nil && err2 == nil {
		gcd := Euclid_GCD( a, b ) // Evaluate GCD of args(int) => a, b
		fmt.Println(gcd) // Print divisor to console
		return // End script
    } fmt.Println("Error", err1, err2) // Errors happened
}
\end{lstlisting}

{\large Explaination\\}

Following the steps of Euclids algorithm detailed in section \texttt{{\bf Euclid's Algorithm}}, the GCD between any two numbers is determined. The Golang function, \texttt{{\bf Euclid-GCD}}, detailed step-by-step in section \texttt{{\bf Code (Golang)}}, determines the GCD by recursively subtracting one non-zero integer by the other.\\\\

{\large How to run:\\}
1--3 need only be done once:

(1) Install Golang

(2) Init Golang project: \texttt{go mod init} 

(3) Compile: \texttt{go build gcd.go} 

(4) Run: \texttt{./gcd.go [int arg1] [int arg2]} 

\subsection{Week 2}
{\large Task 1\\}
\begin{lstlisting}
select_evens :: [a] -> [a]
select_evens [] = []
select_evens (x:xs) = select_odds(xs)

select_odds :: [a] -> [a]
select_odds [] = []
select_odds (x:xs) = [x] ++ select_evens(xs)

revert :: [a] -> [a]  
revert [] = []  
revert (x:xs) = revert xs ++ [x]  

append :: [a] -> [a] -> [a]
append [] x = x
append (x:xs) b = x : append xs b
\end{lstlisting}

{\large Task 2\\}
append [2,5,4,3] 5 \\
-{\textgreater} [2]:[5]:[4]:[3]: 5 \\
-{\textgreater} [2,5,4,3,5]

\subsection{Week 3}
\begin{verbatim}

Completed 'fill in the dot' execution:
\end{verbatim}
\begin{lstlisting}
hanoi 5 0 2  
	hanoi 4 0 1 
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move  0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move  1 2  
				hanoi 1 0 2 = move 0 2 
		move 0 1
		hanoi 3 2 1
			hanoi 2 2 0
				hanoi 1 2 1 = move 2 1
				move 2 0
				hanoi 1 1 0 = move 1 0
			move 2 1
			hanoi 2 0 1
				hanoi 1 0 2 = move 0 2
				move 0 1
				hanoi 1 2 1 = move 2 1
	move 0 2
	hanoi 4 1 2
		hanoi 3 1 0
			hanoi 2 1 2
				hanoi 1 1 0 = move 1 0
				move 1 2
				hanoi 1 0 2 = move 0 2
			move 1 0
			hanoi 2 2 0
				hanoi 1 2 1 = move 2 1
				move 2 0
				hanoi 1 1 0 = move 1 0
		move 1 2
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move  0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move  1 2  
				hanoi 1 0 2 = move 0 2 
			|
		|
	|
|


\end{lstlisting}
\begin{verbatim}
The word 'hanoi' appears 31 times for a tower of height 5. Hanoi will execute {2^n - 1}  times

Javascript-ish formula to solve Tower of Hanoi with n discs:
\end{verbatim}
\begin{lstlisting}

func hanoi(  n, x, y ) {
	switch( n ) {
		case 1:
			move( x, y );
			break;
		default:
			hanoi ( n-1, x, other( x, y ) );
			move( x, y );
			hanoi ( n-1, other( x, y ), y );
			break;
	}
}

func move( x, y )  {
    // move top disk of position x to position y
}

func other( x, y ) {
	return (2 * ( x + y ))  % 3;
}

\end{lstlisting}

\subsection{Week 4}
{\large derivation trees\\}

\includegraphics[width=1\textwidth]{tree.jpeg}

{\large "More exercises"\\}
Why do the following strings not have parse trees (given the context-free grammar above)?

\begin{verbatim}
 2-1: No rule for subtraction
 1.0+2: Only rules for integers
 6/3: No specification for division
 8 mod 6: No specification for modulus
\end{verbatim}

Can you change the grammar, so that the strings in the previous exercise become parsable?

\begin{verbatim}
 yes you can, I would assume for modulus as well
\end{verbatim}

write out the abstract syntax trees for the following strings:
\begin{verbatim}
 2+1: Plus (Num 2) (Num 1)
 1+2*3: Plus (Num 1) (Times (Num 2) (Num 3))
 1+(2*3): Plus (Num 1) (Times (Num 2) (Num 3))
 (1+2)*3: Times (Plus (Num 1) (Num 2)) (Num 3)
\end{verbatim}

Is the abstract syntax tree of 1+2+3 identical to the one of (1+2)+3 or the one of 1+(2+3)?
\begin{verbatim}
 No particular right answer.
\end{verbatim}

\subsection{Week 5 (line 300)} 

Use the parser to generate linearized abstract syntax trees for the following expressions:

\parindent x
\begin{verbatim}
Prog (EVar (Id "x"))
\end{verbatim}
x x
\begin{verbatim}
Prog (EApp (EVar (Id "x")) (EVar (Id "x")))
\end{verbatim}
x y
\begin{verbatim}
Prog (EApp (EVar (Id "x")) (EVar (Id "y")))
\end{verbatim}
x y z
\begin{verbatim}
Prog (EApp (EApp (EVar (Id "x")) (EVar (Id "y"))) (EVar (Id "z")))
\end{verbatim}
\textbackslash x.x
\begin{verbatim}
Prog (EAbs (Id "x") (EVar (Id "x")))
\end{verbatim}
\textbackslash x.x x
\begin{verbatim}
Prog (EAbs (Id "x") (EApp (EVar (Id "x")) (EVar (Id "x"))))
\end{verbatim}
(\textbackslash x . (\textbackslash y . x y)) (\textbackslash x.x) z
\begin{verbatim}
Prog (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EApp (EVar (Id "x")) (EVar (Id "y"))))) (EAbs (Id "x") 
(EVar (Id "x")))) (EVar (Id "z")))
\end{verbatim}
(\textbackslash x . \textbackslash y . x y z) a b c
\begin{verbatim}
Prog (EApp (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EApp (EApp (EVar (Id "x")) 
(EVar (Id "y"))) (EVar (Id "z"))))) (EVar (Id "a"))) (EVar (Id "b"))) (EVar (Id "c")))
\end{verbatim}

Write out the abstract syntax trees in 2-dimensional notation using pen and paper.

\includegraphics[width=.80\textwidth]{wk5_abstracttrees.png}

Evaluate using pen-and-paper [2] the following expressions:

\includegraphics[width=.5\textwidth]{wk5_lambdasemantics.png}

Evaluate (\x.x)((\y.y)a) by executing the function evalCBN defined on line 26-28 in Interpreter.hs pen-and-paper. The function subst is doing capture avoiding substitution and you can reduce subst in one step in your pen and paper computation

\includegraphics[width=.5\textwidth]{wk5_evalcbn.png}

\subsection{Week 6 (line 350}

\begin{verbatim}
Reduce the following lambda calculus expression:

    (\exp . \two . \three . exp two three)
    (\m.\n. m n)
    (\f.\x. f (f x))
    (\f.\x. f (f (f x)))

 
    ( (\m.\n. m n) (\f.\x. f (f x)) (\f.\x. f (f (f x))) )  --β Substitution

    ( (\m.\n. m n) (\f.\x. f (f x)) (\x0.\x1. x0 (x0 (x0 x1))) )  --α conversion

    ( (\n.  (\f.(\x. f (f x))) n) (\x0.(\x1. x0 (x0 (x0 x1)))) )  --β Substitution

    ( (\f.(\x. f (f x))) (\x0.(\x1. x0 (x0 (x0 x1)))) )  --β Substitution

    ( ((\x. (\x0.(\x1. x0 (x0 (x0 x1)))) ((\x0.(\x1. x0 (x0 (x0 x1)))) x))) )  --β Substitution

    ( ((\x. (\x0.(\x1. x0 (x0 (x0 x1)))) ((\x2.(\x3. x2 (x2 (x2 x3)))) x))) )  --α conversion

    ( ((\x. ((\x1. ((\x2.(\x3. x2 (x2 (x2 x3)))) x) (((\x2.(\x3. x2 (x2 (x2 x3)))) x) 
    (((\x2.(\x3. x2 (x2 (x2 x3)))) x) x1)))) )) )  --β Substitution

    ( ((\x. ((\x1. ((\x2.(\x3. x2 (x2 (x2 x3)))) x) (((\x4.(\x5. x4 (x4 (x4 x5)))) x) 
    (((\x6.(\x7. x6 (x6 (x6 x7)))) x) x1)))) )) )  --α conversion

    ( ((\x. ((\x1. (\x3. x (x (x x3))) (((\x4.(\x5. x4 (x4 (x4 x5)))) x) 
    (((\x6.(\x7. x6 (x6 (x6 x7)))) x) x1)) )))))  --β Substitution

    (\x. (\x1. (x (x (x (((\x4.(\x5. x4 (x4 (x4 x5)))) x) (((\x6.(\x7. x6 (x6 (x6 x7)))) x) 
    x1)) )))))  --β Substitution

    (\x. (\x1. (x (x (x (((\x5. x (x (x x5)))) (((\x6.(\x7. x6 (x6 (x6 x7)))) x) 
    x1)) )))))  --β Substitution

    (\x. (\x1. (x (x (x (x (x (x (((\x6.(\x7. x6 (x6 (x6 x7)))) x) x1)))) )))))  --β Substitution

    (\x. (\x1. (x (x (x (x (x (x ((\x7. x (x (x x7))) x1)))) )))))  --β Substitution

    (\x. (\x1. (x (x (x (x (x (x (x (x (x x1)))))))) )))  --β Substitution, final

Algrbra formula:

    f(m,n) = n^m
\end{verbatim}



% \ldots

\section{Project}

Introductory remarks ...

The following structure should be suitable for most practical projects. 

\subsection{Specification}

For my project I wish to design an interpreter for a programming language of my own design.



\href{https://www.stephendiehl.com/llvm/}{Possible launch point}

\subsection{Prototype}
\subsection{Documentation}
\subsection{Critical Appraisal}

\ldots

\section{Conclusions}\label{conclusions}

% (approx 400 words)

Thanks, goodbye.

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.
\end{thebibliography}

% \includegraphics {sss.png}
\end{document}
