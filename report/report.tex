\documentclass{article}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Go,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Tyler Lewis  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Updated throughout Fall 2022 for 354 Programming Languages at Chapman Univ.
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

Tylers introduction. Yeah, this will get some work before final submission. 


\section{Homework}\label{homework}

\subsection{Week 1}

% \section{Greatest Common Divisor (GCD)}
{\large \\\\Euclid's Algorithm\\\\}
Input: Two whole numbers (integers) called a and b, both greater than 0.

(1) if a {\textless} b then replace a by (a - b). 

(2) if b {\textgreater} a then replace b by (b - a).

(3) Repeat from (1) if a {\neq} b \\ 

Output: a.\\\\

{\large Code (Golang)}
\begin{lstlisting}
package main
import ( "fmt"; "strconv"; "os")
// Calculate GCD of a & b using Euclid's algorithm
func Euclid-GCD( a int, b int ) int {
    if a > b { return Euclid_GCD( a-b, b ) } // recursive GCD function
    if a < b { return Euclid_GCD( a, b-a ) } // Subtract lesser from greater
	return a // a == b End recursive function
} func main() {
    // Args(str) int conversion 
	a, err1 := strconv.Atoi(os.Args[1]); b, err2 := strconv.Atoi(os.Args[2])
    // If no errors:
	if err1 == nil && err2 == nil {
		gcd := Euclid_GCD( a, b ) // Evaluate GCD of args(int) => a, b
		fmt.Println(gcd) // Print divisor to console
		return // End script
    } fmt.Println("Error", err1, err2) // Errors happened
}
\end{lstlisting}

{\large Explaination\\}

Following the steps of Euclids algorithm detailed in section \texttt{{\bf Euclid's Algorithm}}, the GCD between any two numbers is determined. The Golang function, \texttt{{\bf Euclid-GCD}}, detailed step-by-step in section \texttt{{\bf Code (Golang)}}, determines the GCD by recursively subtracting one non-zero integer by the other.\\\\

{\large How to run:\\}
1--3 need only be done once:

(1) Install Golang

(2) Init Golang project: \texttt{go mod init} 

(3) Compile: \texttt{go build gcd.go} 

(4) Run: \texttt{./gcd.go [int arg1] [int arg2]} 

\subsection{Week 2}
{\large Task 1\\}
\begin{lstlisting}
select_evens :: [a] -> [a]
select_evens [] = []
select_evens (x:xs) = select_odds(xs)

select_odds :: [a] -> [a]
select_odds [] = []
select_odds (x:xs) = [x] ++ select_evens(xs)

revert :: [a] -> [a]  
revert [] = []  
revert (x:xs) = revert xs ++ [x]  

append :: [a] -> [a] -> [a]
append [] x = x
append (x:xs) b = x : append xs b
\end{lstlisting}

{\large Task 2\\}
append [2,5,4,3] 5 \\
-{\textgreater} [2]:[5]:[4]:[3]: 5 \\
-{\textgreater} [2,5,4,3,5]

\subsection{Week 3}
\begin{verbatim}

Completed 'fill in the dot' execution:
\end{verbatim}
\begin{lstlisting}
hanoi 5 0 2  
	hanoi 4 0 1 
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move  0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move  1 2  
				hanoi 1 0 2 = move 0 2 
		move 0 1
		hanoi 3 2 1
			hanoi 2 2 0
				hanoi 1 2 1 = move 2 1
				move 2 0
				hanoi 1 1 0 = move 1 0
			move 2 1
			hanoi 2 0 1
				hanoi 1 0 2 = move 0 2
				move 0 1
				hanoi 1 2 1 = move 2 1
	move 0 2
	hanoi 4 1 2
		hanoi 3 1 0
			hanoi 2 1 2
				hanoi 1 1 0 = move 1 0
				move 1 2
				hanoi 1 0 2 = move 0 2
			move 1 0
			hanoi 2 2 0
				hanoi 1 2 1 = move 2 1
				move 2 0
				hanoi 1 1 0 = move 1 0
		move 1 2
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move  0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move  1 2  
				hanoi 1 0 2 = move 0 2 
			|
		|
	|
|


\end{lstlisting}
\begin{verbatim}
The word 'hanoi' appears 31 times for a tower of height 5. Hanoi will execute {2^n - 1}  times

Javascript-ish formula to solve Tower of Hanoi with n discs:
\end{verbatim}
\begin{lstlisting}

func hanoi(  n, x, y ) {
	switch( n ) {
		case 1:
			move( x, y );
			break;
		default:
			hanoi ( n-1, x, other( x, y ) );
			move( x, y );
			hanoi ( n-1, other( x, y ), y );
			break;
	}
}

func move( x, y )  {
    // move top disk of position x to position y
}

func other( x, y ) {
	return (2 * ( x + y ))  % 3;
}

\end{lstlisting}

\subsection{Week 4}
{\large derivation trees\\}

\includegraphics[width=1\textwidth]{tree.jpeg}

{\large "More exercises"\\}
Why do the following strings not have parse trees (given the context-free grammar above)?

\begin{verbatim}
 2-1: No rule for subtraction
 1.0+2: Only rules for integers
 6/3: No specification for division
 8 mod 6: No specification for modulus
\end{verbatim}

Can you change the grammar, so that the strings in the previous exercise become parsable?

\begin{verbatim}
 yes you can, I would assume for modulus as well
\end{verbatim}

write out the abstract syntax trees for the following strings:
\begin{verbatim}
 2+1: Plus (Num 2) (Num 1)
 1+2*3: Plus (Num 1) (Times (Num 2) (Num 3))
 1+(2*3): Plus (Num 1) (Times (Num 2) (Num 3))
 (1+2)*3: Times (Plus (Num 1) (Num 2)) (Num 3)
\end{verbatim}

Is the abstract syntax tree of 1+2+3 identical to the one of (1+2)+3 or the one of 1+(2+3)?
\begin{verbatim}
 No particular right answer.
\end{verbatim}


% \ldots

\section{Project}

Introductory remarks ...

The following structure should be suitable for most practical projects. 

\subsection{Specification}
\subsection{Prototype}
\subsection{Documentation}
\subsection{Critical Appraisal}

\ldots

\section{Conclusions}\label{conclusions}

% (approx 400 words)

Thanks, goodbye.

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.
\end{thebibliography}

\includegraphics {sss.png}
\end{document}
